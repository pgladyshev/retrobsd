SIGNAL(3C)							    SIGNAL(3C)



NNAAMMEE
       signal -	simplified software signal facilities

SSYYNNOOPPSSIISS
       ##iinncclluuddee	<<ssiiggnnaall..hh>>

       ((**ssiiggnnaall((ssiigg,, ffuunncc))))(())
       iinntt ((**ffuunncc))(());;

DDEESSCCRRIIPPTTIIOONN
       _S_i_g_n_a_l  is  a simplified	interface to the more general _s_i_g_v_e_c(2)	facil-
       ity.

       A signal	is generated by	some abnormal event, initiated by a user at  a
       terminal	(quit, interrupt, stop), by a program error (bus error,	etc.),
       by request of another program (kill), or	 when  a  process  is  stopped
       because	it  wishes  to	access its control terminal while in the back-
       ground (see _t_t_y(4)).  Signals are optionally generated when  a  process
       resumes	after  being  stopped,	when  the  status  of  child processes
       changes,	or when	input is ready at the control terminal.	 Most  signals
       cause  termination of the receiving process if no action	is taken; some
       signals instead cause the process receiving them	to be stopped, or  are
       simply  discarded  if  the process has not requested otherwise.	Except
       for the SIGKILL and SIGSTOP signals, the	 _s_i_g_n_a_l	 call  allows  signals
       either  to be ignored or	to cause an interrupt to a specified location.
       The following is	a list of all signals with names  as  in  the  include
       file <_s_i_g_n_a_l_._h>:

       SIGHUP	 1    hangup
       SIGINT	 2    interrupt
       SIGQUIT	 3*   quit
       SIGILL	 4*   illegal instruction
       SIGTRAP	 5*   trace trap
       SIGIOT	 6*   IOT instruction
       SIGEMT	 7*   EMT instruction
       SIGFPE	 8*   floating point exception
       SIGKILL	 9    kill (cannot be caught or	ignored)
       SIGBUS	 10*  bus error
       SIGSEGV	 11*  segmentation violation
       SIGSYS	 12*  bad argument to system call
       SIGPIPE	 13   write on a pipe with no one to read it
       SIGALRM	 14   alarm clock
       SIGTERM	 15   software termination signal
       SIGURG	 16@  urgent condition present on socket
       SIGSTOP	 17'|+'stop (cannot be caught or	ignored)
       SIGTSTP	 18'|+'stop signal generated from keyboard
       SIGCONT	 19@  continue after stop
       SIGCHLD	 20@  child status has changed
       SIGTTIN	 21'|+'background read attempted	from control terminal
       SIGTTOU	 22'|+'background write attempted to control terminal
       SIGIO	 23@  i/o is possible on a descriptor (see _f_c_n_t_l(2))
       SIGXCPU	 24   cpu time limit exceeded (see _s_e_t_r_l_i_m_i_t(2))
       SIGXFSZ	 25   file size	limit exceeded (see _s_e_t_r_l_i_m_i_t(2))
       SIGVTALRM 26   virtual time alarm (see _s_e_t_i_t_i_m_e_r(2))
       SIGPROF	 27   profiling	timer alarm (see _s_e_t_i_t_i_m_e_r(2))
       SIGWINCH	 28@  Window size change
       SIGUSR1	 30   User defined signal 1
       SIGUSR2	 31   User defined signal 2

       The  starred signals in the list	above cause a core image if not	caught
       or ignored.

       If _f_u_n_c is SIG_DFL, the default action for signal  _s_i_g  is  reinstated;
       this  default  is  termination  (with a core image for starred signals)
       except for signals marked with @	or '|+'.	 Signals  marked  with	@  are
       discarded  if  the action is SIG_DFL; signals marked with '|+' cause the
       process to stop.	 If _f_u_n_c is SIG_IGN the	signal is subsequently ignored
       and pending instances of	the signal are discarded.  Otherwise, when the
       signal occurs further  occurrences  of  the  signal  are	 automatically
       blocked and _f_u_n_c	is called.

       A  return  from	the function unblocks the handled signal and continues
       the process at the point	it was interrupted.   UUnnlliikkee  pprreevviioouuss	ssiiggnnaall
       ffaacciilliittiieess,,  tthhee	hhaannddlleerr	_f_u_n_c rreemmaaiinnss iinnssttaalllleedd aafftteerr aa ssiiggnnaall hhaass bbeeeenn
       ddeelliivveerreedd..

       If a caught signal occurs during	certain	system calls, causing the call
       to terminate prematurely, the call is automatically restarted.  In par-
       ticular this can	occur during a _r_e_a_d or _w_r_i_t_e(2)	on a slow device (such
       as a terminal; but not a	file) and during a _w_a_i_t(2).

       The  value of _s_i_g_n_a_l is the previous (or	initial) value of _f_u_n_c for the
       particular signal.

       After a _f_o_r_k(2) or _v_f_o_r_k(2) the child inherits all signals.   _E_x_e_c_v_e(2)
       resets all caught signals to the	default	action;	ignored	signals	remain
       ignored.

RREETTUURRNN VVAALLUUEE
       The previous action is returned on a successful call.  Otherwise, -1 is
       returned	and _e_r_r_n_o is set to indicate the error.

EERRRROORRSS
       _S_i_g_n_a_l  will fail and no	action will take place if one of the following
       occur:

       [EINVAL]	      _S_i_g is not a valid signal	number.

       [EINVAL]	      An attempt is made to ignore or  supply  a  handler  for
		      SIGKILL or SIGSTOP.

       [EINVAL]	      An attempt is made to ignore SIGCONT (by default SIGCONT
		      is ignored).

SSEEEE AALLSSOO
       kill(1),	ptrace(2),  kill(2),  sigvec(2),  sigblock(2),	sigsetmask(2),
       sigpause(2), sigstack(2), setjmp(3), tty(4)

NNOOTTEESS  ((VVAAXX--1111))
       The handler routine can be declared:

	   handler(sig,	code, scp)

       Here _s_i_g	is the signal number, into which the hardware faults and traps
       are mapped as defined below.  Code is a parameter  which	 is  either  a
       constant	 as  given  below  or, for compatibility mode faults, the code
       provided	by the hardware.  _S_c_p is a pointer to  the  _s_t_r_u_c_t  _s_i_g_c_o_n_t_e_x_t
       used  by	the system to restore the process context from before the sig-
       nal.  Compatibility mode	faults are distinguished from the other	SIGILL
       traps by	having PSL_CM set in the psl.

       The  following  defines	the  mapping  of hardware traps	to signals and
       codes.  All of these symbols are	defined	in <_s_i_g_n_a_l_._h>:

	  Hardware condition		      Signal	   Code

       Arithmetic traps:
	  Integer overflow		      SIGFPE	   FPE_INTOVF_TRAP
	  Integer division by zero	      SIGFPE	   FPE_INTDIV_TRAP
	  Floating overflow trap	      SIGFPE	   FPE_FLTOVF_TRAP
	  Floating/decimal division by zero   SIGFPE	   FPE_FLTDIV_TRAP
	  Floating underflow trap	      SIGFPE	   FPE_FLTUND_TRAP
	  Decimal overflow trap		      SIGFPE	   FPE_DECOVF_TRAP
	  Subscript-range		      SIGFPE	   FPE_SUBRNG_TRAP
	  Floating overflow fault	      SIGFPE	   FPE_FLTOVF_FAULT
	  Floating divide by zero fault	      SIGFPE	   FPE_FLTDIV_FAULT
	  Floating underflow fault	      SIGFPE	   FPE_FLTUND_FAULT
       Length access control		      SIGSEGV
       Protection violation		      SIGBUS
       Reserved	instruction		      SIGILL	   ILL_RESAD_FAULT
       Customer-reserved instr.		      SIGEMT
       Reserved	operand			      SIGILL	   ILL_PRIVIN_FAULT
       Reserved	addressing		      SIGILL	   ILL_RESOP_FAULT
       Trace pending			      SIGTRAP
       Bpt instruction			      SIGTRAP
       Compatibility-mode		      SIGILL	   hardware supplied code
       Chme				      SIGSEGV
       Chms				      SIGSEGV
       Chmu				      SIGSEGV

NNOOTTEESS  ((PPDDPP--1111))
       The handler routine can be declared:

	   handler(sig,	code, scp)
	   int sig, code;
	   struct sigcontext *scp;

       Here _s_i_g	is the signal number, into which the hardware faults and traps
       are mapped as defined below.  _C_o_d_e is a parameter that is a constant as
       given below.  _S_c_p is a pointer to the _s_i_g_c_o_n_t_e_x_t	structure (defined  in
       <_s_i_g_n_a_l_._h>), used to restore the	context	from before the	signal.

       The  following  defines	the  mapping  of hardware traps	to signals and
       codes.  All of these symbols are	defined	in <_s_i_g_n_a_l_._h>:

	  Hardware condition		      Signal	   Code

       Arithmetic traps:
	  Floating overflow trap	      SIGFPE	   FPE_FLTOVF_TRAP
	  Floating/decimal division by zero   SIGFPE	   FPE_FLTDIV_TRAP
	  Floating underflow trap	      SIGFPE	   FPE_FLTUND_TRAP
	  Decimal overflow trap		      SIGFPE	   FPE_DECOVF_TRAP
	  Illegal return code		      SIGFPE	   FPE_CRAZY
	  Bad op code			      SIGFPE	   FPE_OPCODE_TRAP
	  Bad operand			      SIGFPE	   FPE_OPERAND_TRAP
	  Maintenance trap		      SIGFPE	   FPE_MAINT_TRAP
       Length access control		      SIGSEGV
       Protection violation (odd address)     SIGBUS
       Reserved	instruction		      SIGILL	   ILL_RESAD_FAULT
       Customer-reserved instr.		      SIGEMT
       Trace pending			      SIGTRAP
       Bpt instruction			      SIGTRAP

       The handler routine must	save any registers it uses  and	 restore  them
       before  returning.   On	the  PDP-11, the kernel	saves _r_0 and _r_1	before
       calling the handler routine, but	expect the handler to save  any	 other
       registers it uses.  The standard	entry code generated by	the C compiler
       for handler routines written in C  automatically	 saves	the  remaining
       general	registers,  but	 floating point	registers are _n_o_t saved.  As a
       result there is currently no [standard] method for  a  handler  routine
       written	in  C to perform floating point	operations without blowing the
       interrupted program out of the water.



4th Berkeley Distribution	 May 20, 1986			    SIGNAL(3C)
