CSH(1)			    General Commands Manual			CSH(1)



NNAAMMEE
       csh - a shell (command interpreter) with	C-like syntax

SSYYNNOOPPSSIISS
       ccsshh [ --cceeffiinnssttvvVVxxXX ] [ arg ...  ]

DDEESSCCRRIIPPTTIIOONN
       _C_s_h  is a first implementation of a command language interpreter	incor-
       porating	a history mechanism (see HHiissttoorryy SSuubbssttiittuuttiioonnss),  job  control
       facilities  (see	 JJoobbss),	interactive file name and user name completion
       (see FFiillee NNaammee CCoommpplleettiioonn), and a C-like	syntax.	 So as to be  able  to
       use  its	 job control facilities, users of _c_s_h must (and	automatically)
       use the new tty driver fully described in _t_t_y(4).  This new tty	driver
       allows  generation  of  interrupt  characters from the keyboard to tell
       jobs to stop.  See _s_t_t_y(1) for details on setting options  in  the  new
       tty driver.

       An  instance of _c_s_h begins by executing commands	from the file `.cshrc'
       in the _h_o_m_e directory of	the invoker.  If this is a login shell then it
       also executes commands from the file `.login' there.  It	is typical for
       users on	crt's to put the command ``stty	crt'' in  their	 _._l_o_g_i_n	 file,
       and to also invoke _t_s_e_t(1) there.

       In the normal case, the shell will then begin reading commands from the
       terminal, prompting with	`% '.  Processing of arguments and the use  of
       the shell to process files containing command scripts will be described
       later.

       The shell then repeatedly performs the following	 actions:  a  line  of
       command input is	read and broken	into _w_o_r_d_s.  This sequence of words is
       placed on the command history list and then parsed.  Finally each  com-
       mand in the current line	is executed.

       When  a	login  shell  terminates  it  executes	commands from the file
       `.logout' in the	users home directory.

       LLeexxiiccaall ssttrruuccttuurree

       The shell splits	input lines into words at blanks  and  tabs  with  the
       following  exceptions.  The characters `&' `|' `;' `<' `>' `(' `)' form
       separate	words.	If doubled in `&&', `||', `<<'	or  `>>'  these	 pairs
       form  single  words.   These  parser metacharacters may be made part of
       other words, or prevented their special meaning,	by preceding them with
       `\'.  A newline preceded	by a `\' is equivalent to a blank.

       In  addition  strings enclosed in matched pairs of quotations, `'', ``'
       or `"', form parts of a word; metacharacters in these strings,  includ-
       ing blanks and tabs, do not form	separate words.	 These quotations have
       semantics to be described subsequently.	Within pairs  of  `''  or  `"'
       characters a newline preceded by	a `\' gives a true newline character.

       When  the shell's input is not a	terminal, the character	`#' introduces
       a comment which continues to the	end of the input  line.	  It  is  pre-
       vented  this  special  meaning  when  preceded by `\' and in quotations
       using ``', `'', and `"'.

       CCoommmmaannddss

       A simple	command	is a sequence of words,	the first of  which  specifies
       the  command  to	be executed.  A	simple command or a sequence of	simple
       commands	separated by `|' characters forms a pipeline.  The  output  of
       each  command  in  a  pipeline  is  connected to	the input of the next.
       Sequences of pipelines may be separated by `;', and are	then  executed
       sequentially.   A sequence of pipelines may be executed without immedi-
       ately waiting for it to terminate by following it with an `&'.

       Any of the above	may be placed in `(' `)'  to  form  a  simple  command
       (which  may be a	component of a pipeline, etc.)	It is also possible to
       separate	pipelines with `||' or `&&' indicating,	as in the C  language,
       that  the  second is to be executed only	if the first fails or succeeds
       respectively. (See _E_x_p_r_e_s_s_i_o_n_s_._)

       JJoobbss

       The shell associates a _j_o_b with each pipeline.  It  keeps  a  table  of
       current jobs, printed by	the _j_o_b_s command, and assigns them small inte-
       ger numbers.  When a job	is started asynchronously with `&', the	 shell
       prints a	line which looks like:

	    [1]	1234

       indicating that the job which was started asynchronously	was job	number
       1 and had one (top-level) process, whose	process	id was 1234.

       If you are running a job	and wish to do something else you may hit  the
       key  ^^ZZ	(control-Z) which sends	a STOP signal to the current job.  The
       shell will then normally	indicate that the job has been `Stopped',  and
       print  another  prompt.	You can	then manipulate	the state of this job,
       putting it in the background with the _b_g	command,  or  run  some	 other
       commands	 and  then  eventually	bring the job back into	the foreground
       with the	foreground command _f_g.	A ^^ZZ takes effect immediately  and  is
       like an interrupt in that pending output	and unread input are discarded
       when it is typed.  There	is another special key ^^YY which	does not  gen-
       erate  a	 STOP signal until a program attempts to _r_e_a_d(2) it.  This can
       usefully	be typed ahead when you	have prepared some commands for	a  job
       which you wish to stop after it has read	them.

       A  job  being  run in the background will stop if it tries to read from
       the terminal.  Background jobs are normally allowed to produce  output,
       but this	can be disabled	by giving the command ``stty tostop''.	If you
       set this	tty option, then background jobs will stop when	 they  try  to
       produce output like they	do when	they try to read input.

       There  are  several  ways to refer to jobs in the shell.	 The character
       `%' introduces a	job name.  If you wish to refer	to job number  1,  you
       can  name  it  as `%1'.	Just naming a job brings it to the foreground;
       thus `%1' is a synonym for `fg %1', bringing job	1 back into the	 fore-
       ground.	Similarly saying `%1 &'	resumes	job 1 in the background.  Jobs
       can also	be named by prefixes of	the string typed in to start them,  if
       these  prefixes	are  unambiguous,  thus	`%ex' would normally restart a
       suspended _e_x(1) job, if there were only one suspended  job  whose  name
       began  with  the	 string	 `ex'.	 It is also possible to	say `%?string'
       which specifies a job whose text	contains _s_t_r_i_n_g_, if there is only  one
       such job.

       The shell maintains a notion of the current and previous	jobs.  In out-
       put pertaining to jobs, the current job is marked with a	 `+'  and  the
       previous	 job  with a `-'.  The abbreviation `%+' refers	to the current
       job and `%-' refers to the previous job.	 For close  analogy  with  the
       syntax  of the _h_i_s_t_o_r_y mechanism	(described below), `%%'	is also	a syn-
       onym for	the current job.

       SSttaattuuss rreeppoorrttiinngg

       This shell learns immediately whenever a	 process  changes  state.   It
       normally	 informs you whenever a	job becomes blocked so that no further
       progress	is possible, but only just before it prints a prompt.  This is
       done so that it does not	otherwise disturb your work.  If, however, you
       set the shell variable _n_o_t_i_f_y_, the shell	will notify you	immediately of
       changes	of  status  in background jobs.	 There is also a shell command
       _n_o_t_i_f_y which marks a single process so that its status changes will  be
       immediately  reported.	By  default  _n_o_t_i_f_y marks the current process;
       simply say `notify' after starting a background job to mark it.

       When you	try to leave the shell while jobs are  stopped,	 you  will  be
       warned  that  `You have stopped jobs.'  You may use the _j_o_b_s command to
       see what	they are.  If you do this or immediately try  to  exit	again,
       the  shell will not warn	you a second time, and the suspended jobs will
       be terminated.

       FFiillee NNaammee CCoommpplleettiioonn

       When the	file name completion feature is	enabled	by setting  the	 shell
       variable	 _f_i_l_e_c	(see  sseett), _c_s_h	will interactively complete file names
       and user	names from unique prefixes, when they are input	from the  ter-
       minal  followed by the escape character (the escape key,	or control-[).
       For example, if the current directory looks like
		 DSC.OLD   bin	     cmd       lib	 xmpl.c
		 DSC.NEW   chaosnet  cmtest    mail	 xmpl.o
		 bench	   class     dev       mbox	 xmpl.out
       and the input is
		 % vi ch<escape>
       _c_s_h will	complete the prefix ``ch'' to  the  only  matching  file  name
       ``chaosnet'', changing the input	line to
		 % vi chaosnet
       However,	given
		 % vi D<escape>
       _c_s_h will	only expand the	input to
		 % vi DSC.
       and  will  sound	 the  terminal	bell to	indicate that the expansion is
       incomplete, since there are two file names matching the prefix ``D''.

       If a partial file name is followed by the end-of-file  character	 (usu-
       ally  control-D),  then,	 instead of completing the name, _c_s_h will list
       all file	names matching the prefix.  For	example, the input
		 % vi D<control-D>
       causes all files	beginning with ``D'' to	be listed:
		 DSC.NEW   DSC.OLD
       while the input line remains unchanged.

       The same	system of escape and end-of-file can also be  used  to	expand
       partial user names, if the word to be completed (or listed) begins with
       the character ``~''.  For example, typing
		 cd ~ro<control-D>
       may produce the expansion
		 cd ~root

       The use of the terminal bell to signal errors or	multiple  matches  can
       be inhibited by setting the variable _n_o_b_e_e_p.

       Normally, all files in the particular directory are candidates for name
       completion.  Files with certain suffixes	can be excluded	from consider-
       ation  by  setting  the	variable _f_i_g_n_o_r_e to the	list of	suffixes to be
       ignored.	 Thus, if _f_i_g_n_o_r_e is set by the	command
		 % set fignore = (.o .out)
       then typing
		 % vi x<escape>
       would result in the completion to
		 % vi xmpl.c
       ignoring	the files "xmpl.o" and "xmpl.out".  However, if	the only  com-
       pletion	possible  requires  not	ignoring these suffixes, then they are
       not ignored.  In	addition, _f_i_g_n_o_r_e does not affect the listing of  file
       names by	control-D.  All	files are listed regardless of their suffixes.

       SSuubbssttiittuuttiioonnss

       We  now	describe the various transformations the shell performs	on the
       input in	the order in which they	occur.

       HHiissttoorryy ssuubbssttiittuuttiioonnss

       History substitutions place words from previous command input  as  por-
       tions  of new commands, making it easy to repeat	commands, repeat argu-
       ments of	a previous command in the current  command,  or	 fix  spelling
       mistakes	 in  the previous command with little typing and a high	degree
       of confidence.  History substitutions begin with	the character `!'  and
       may  begin  aannyywwhheerree in the input stream	(with the proviso that they ddoo
       nnoott nest.)  This	`!' may	be preceded by an `\' to prevent  its  special
       meaning;	for convenience, a `!' is passed unchanged when	it is followed
       by a blank, tab,	newline, `='  or  `('.	 (History  substitutions  also
       occur  when  an	input line begins with `^'.  This special abbreviation
       will be described later.)  Any input line which contains	 history  sub-
       stitution  is  echoed on	the terminal before it is executed as it could
       have been typed without history substitution.

       Commands	input from the terminal	which consist of one or	more words are
       saved  on  the  history	list.	The  history substitutions reintroduce
       sequences of words from these saved commands  into  the	input  stream.
       The  size  of which is controlled by the	_h_i_s_t_o_r_y	variable; the previous
       command is always retained, regardless of its value.  Commands are num-
       bered sequentially from 1.

       For  definiteness,  consider the	following output from the _h_i_s_t_o_r_y com-
       mand:

	     9	write michael
	    10	ex write.c
	    11	cat oldwrite.c
	    12	diff *write.c

       The commands are	shown with their event numbers.	  It  is  not  usually
       necessary  to  use  event  numbers, but the current event number	can be
       made part of the	_p_r_o_m_p_t by placing an `!' in the	prompt string.

       With the	current	event 13 we can	refer to previous events by event num-
       ber  `!11',  relatively as in `!-2' (referring to the same event), by a
       prefix of a command word	as in `!d' for event 12	or `!wri' for event 9,
       or  by  a string	contained in a word in the command as in `!?mic?' also
       referring to event 9.  These forms, without further modification,  sim-
       ply  reintroduce	the words of the specified events, each	separated by a
       single blank.  As a special case	`!!' refers to the  previous  command;
       thus `!!'  alone	is essentially a _r_e_d_o_.

       To  select words	from an	event we can follow the	event specification by
       a `:' and a designator for the desired words.  The words	 of  an	 input
       line are	numbered from 0, the first (usually command) word being	0, the
       second word (first argument) being 1, etc.  The basic word  designators
       are:

	    0	 first (command) word
	    _n	 _n'th argument
	    ^	 first argument,  i.e. `1'
	    $	 last argument
	    %	 word matched by (immediately preceding) ?_s? search
	    _x-_y	 range of words
	    -_y	 abbreviates `0-_y'
	    *	 abbreviates `^-$', or nothing if only 1 word in event
	    _x*	 abbreviates `_x-$'
	    _x-	 like `_x*' but omitting	word `$'

       The `:' separating the event specification from the word	designator can
       be omitted if the argument selector begins with a `^', `$', `*' `-'  or
       `%'.   After  the  optional word	designator can be placed a sequence of
       modifiers, each	preceded  by  a	 `:'.	The  following	modifiers  are
       defined:

	    h	   Remove a trailing pathname component, leaving the head.
	    r	   Remove a trailing `.xxx' component, leaving the root	name.
	    e	   Remove all but the extension	`.xxx' part.
	    s/_l/_r/ Substitute _l	for _r
	    t	   Remove all leading pathname components, leaving the tail.
	    &	   Repeat the previous substitution.
	    g	   Apply the change globally, prefixing	the above, e.g.	`g&'.
	    p	   Print the new command but do	not execute it.
	    q	   Quote the substituted words,	preventing further substitutions.
	    x	   Like	q, but break into words	at blanks, tabs	and newlines.

       Unless  preceded	by a `g' the modification is applied only to the first
       modifiable word.	 With substitutions, it	is an error for	no word	to  be
       applicable.

       The  left hand side of substitutions are	not regular expressions	in the
       sense of	the editors, but rather	strings.  Any character	may be used as
       the  delimiter  in  place of `/'; a `\' quotes the delimiter into the _l
       and _r strings.  The character `&' in the	right hand side	is replaced by
       the text	from the left.	A `\' quotes `&' also.	A null _l uses the pre-
       vious string either from	a _l or from a  contextual  scan	 string	 _s  in
       `!?_s?'.	The trailing delimiter in the substitution may be omitted if a
       newline follows immediately as may the trailing	`?'  in	 a  contextual
       scan.

       A  history  reference may be given without an event specification, e.g.
       `!$'.  In this case the reference is to the previous command  unless  a
       previous	history	reference occurred on the same line in which case this
       form repeats the	previous reference.  Thus `!?foo?^ !$' gives the first
       and last	arguments from the command matching `?foo?'.

       A  special  abbreviation	 of  a history reference occurs	when the first
       non-blank character of an input line is a `^'.  This is	equivalent  to
       `!:s^'  providing  a convenient shorthand for substitutions on the text
       of the previous line.  Thus `^lb^lib' fixes the spelling	 of  `lib'  in
       the  previous  command.	 Finally,  a  history substitution may be sur-
       rounded with `{'	and `}'	if necessary to	insulate it from  the  charac-
       ters  which  follow.  Thus, after `ls -ld ~paul'	we might do `!{l}a' to
       do `ls -ld ~paula', while `!la' would look for a	command	starting `la'.

       QQuuoottaattiioonnss wwiitthh '' aanndd ""

       The quotation of	strings	by `'' and `"' can be used to prevent  all  or
       some  of	the remaining substitutions.  Strings enclosed in `'' are pre-
       vented any further interpretation.  Strings  enclosed  in  `"'  may  be
       expanded	as described below.

       In  both	 cases	the  resulting	text becomes (all or part of) a	single
       word; only in one special case (see _C_o_m_m_a_n_d _S_u_b_s_t_i_t_i_t_i_o_n	below) does  a
       `"' quoted string yield parts of	more than one word; `''	quoted strings
       never do.

       AAlliiaass ssuubbssttiittuuttiioonn

       The shell maintains a list of aliases which can	be  established,  dis-
       played and modified by the _a_l_i_a_s	and _u_n_a_l_i_a_s commands.  After a command
       line is scanned,	it is parsed into distinct commands and	the first word
       of  each	 command, left-to-right, is checked to see if it has an	alias.
       If it does, then	the text which is the alias for	that command is	reread
       with  the  history  mechanism available as though that command were the
       previous	input line.  The resulting words replace the command and argu-
       ment list.  If no reference is made to the history list,	then the argu-
       ment list is left unchanged.

       Thus if the alias for `ls' is `ls -l' the command `ls /usr'  would  map
       to  `ls	-l /usr', the argument list here being undisturbed.  Similarly
       if the alias for	`lookup' was `grep !^ /etc/passwd' then	`lookup	 bill'
       would map to `grep bill /etc/passwd'.

       If an alias is found, the word transformation of	the input text is per-
       formed and the aliasing process begins  again  on  the  reformed	 input
       line.   Looping	is  prevented if the first word	of the new text	is the
       same as the old by flagging it  to  prevent  further  aliasing.	 Other
       loops are detected and cause an error.

       Note  that the mechanism	allows aliases to introduce parser metasyntax.
       Thus we can `alias print	'pr \!*	| lpr''	to make	a command  which  _p_r_'_s
       its arguments to	the line printer.

       VVaarriiaabbllee	ssuubbssttiittuuttiioonn

       The  shell  maintains  a	set of variables, each of which	has as value a
       list of zero or more words.  Some of these variables  are  set  by  the
       shell  or  referred  to	by  it.	 For instance, the _a_r_g_v	variable is an
       image of	the shell's argument list, and words of	this variable's	 value
       are referred to in special ways.

       The  values  of variables may be	displayed and changed by using the _s_e_t
       and _u_n_s_e_t commands.  Of the variables referred to by the	shell a	number
       are  toggles; the shell does not	care what their	value is, only whether
       they are	set or not.  For instance, the _v_e_r_b_o_s_e variable	 is  a	toggle
       which  causes command input to be echoed.  The setting of this variable
       results from the	--vv command line	option.

       Other operations	treat variables	numerically.  The `@' command  permits
       numeric calculations to be performed and	the result assigned to a vari-
       able.  Variable values are, however, always  represented	 as  (zero  or
       more) strings.  For the purposes	of numeric operations, the null	string
       is considered to	be zero, and the second	and subsequent words of	multi-
       word values are ignored.

       After  the input	line is	aliased	and parsed, and	before each command is
       executed, variable substitution is performed keyed by  `$'  characters.
       This  expansion can be prevented	by preceding the `$' with a `\'	except
       within `"'s where it aallwwaayyss occurs, and	within	`''s  where  it	 nneevveerr
       occurs.	 Strings quoted	by ``' are interpreted later (see _C_o_m_m_a_n_d _s_u_b_-
       _s_t_i_t_u_t_i_o_n below)	so `$' substitution does not occur there until	later,
       if  at  all.  A `$' is passed unchanged if followed by a	blank, tab, or
       end-of-line.

       Input/output redirections are recognized	before variable	expansion, and
       are  variable  expanded	separately.   Otherwise,  the command name and
       entire argument list are	expanded together.  It is  thus	 possible  for
       the  first (command) word to this point to generate more	than one word,
       the first of which becomes the command name,  and  the  rest  of	 which
       become arguments.

       Unless  enclosed	in `"' or given	the `:q' modifier the results of vari-
       able substitution may eventually	be command and	filename  substituted.
       Within  `"',  a variable	whose value consists of	multiple words expands
       to a (portion of) a single word,	with the words of the variables	 value
       separated  by blanks.  When the `:q' modifier is	applied	to a substitu-
       tion the	variable will expand to	multiple words with  each  word	 sepa-
       rated  by  a blank and quoted to	prevent	later command or filename sub-
       stitution.

       The following metasequences are provided	for introducing	variable  val-
       ues into	the shell input.  Except as noted, it is an error to reference
       a variable which	is not set.

       $name
       ${name}
	    Are	replaced by the	words of the value of variable _n_a_m_e_, each sep-
	    arated by a	blank.	Braces insulate	_n_a_m_e from following characters
	    which would	otherwise be part of it.  Shell	variables  have	 names
	    consisting	of up to 20 letters and	digits starting	with a letter.
	    The	underscore character is	considered a letter.
	    If _n_a_m_e is not a shell variable, but is set	 in  the  environment,
	    then  that	value is returned (but :: modifiers and the other forms
	    given below	are not	available in this case).

       $name[selector]
       ${name[selector]}
	    May	be used	to select only some of the words  from	the  value  of
	    _n_a_m_e_.   The	selector is subjected to `$' substitution and may con-
	    sist of a single number or two numbers separated by	 a  `-'.   The
	    first  word	 of  a	variables value	is numbered `1'.  If the first
	    number of a	range is omitted it defaults to	`1'.  If the last mem-
	    ber	 of  a range is	omitted	it defaults to `$#name'.  The selector
	    `*'	selects	all words.  It is not an error for a range to be empty
	    if the second argument is omitted or in range.

       $#name
       ${#name}
	    Gives  the	number	of  words in the variable.  This is useful for
	    later use in a `[selector]'.

       $0
	    Substitutes	the name of the	file from which	command	input is being
	    read.  An error occurs if the name is not known.

       $number
       ${number}
	    Equivalent to `$argv[number]'.

       $*
	    Equivalent to `$argv[*]'.

       The  modifiers  `:h',  `:t',  `:r', `:q'	and `:x' may be	applied	to the
       substitutions above as may `:gh', `:gt' and `:gr'.  If braces  `{'  '}'
       appear  in  the	command	form then the modifiers	must appear within the
       braces.	TThhee ccuurrrreenntt iimmpplleemmeennttaattiioonn aalllloowwss oonnllyy	oonnee  ``::''  mmooddiiffiieerr  oonn
       eeaacchh ``$$''	eexxppaannssiioonn..

       The following substitutions may not be modified with `:'	modifiers.

       $?name
       ${?name}
	    Substitutes	the string `1' if name is set, `0' if it is not.

       $?0
	    Substitutes	 `1' if	the current input filename is known, `0' if it
	    is not.

       $$
	    Substitute the (decimal) process number of the (parent) shell.

       $<
	    Substitutes	a line from the	standard input,	with no	further	inter-
	    pretation thereafter.  It can be used to read from the keyboard in
	    a shell script.

       CCoommmmaanndd aanndd ffiilleennaammee ssuubbssttiittuuttiioonn

       The remaining substitutions, command  and  filename  substitution,  are
       applied	selectively  to	the arguments of builtin commands.  This means
       that portions of	expressions which are not evaluated are	not  subjected
       to these	expansions.  For commands which	are not	internal to the	shell,
       the command name	is substituted	separately  from  the  argument	 list.
       This occurs very	late, after input-output redirection is	performed, and
       in a child of the main shell.

       CCoommmmaanndd ssuubbssttiittuuttiioonn

       Command substitution is indicated by a command enclosed	in  ``'.   The
       output  from  such  a command is	normally broken	into separate words at
       blanks, tabs and	newlines, with null words being	discarded,  this  text
       then  replacing	the original string.  Within `"'s, only	newlines force
       new words; blanks and tabs are preserved.

       In any case, the	single final newline does not force a new word.	  Note
       that  it	is thus	possible for a command substitution to yield only part
       of a word, even if the command outputs a	complete line.

       FFiilleennaammee	ssuubbssttiittuuttiioonn

       If a word contains any of the characters	`*', `?', `[' or `{' or	begins
       with the	character `~', then that word is a candidate for filename sub-
       stitution, also known as	`globbing'.  This word is then regarded	 as  a
       pattern,	 and replaced with an alphabetically sorted list of file names
       which match the pattern.	 In a list of words specifying	filename  sub-
       stitution it is an error	for no pattern to match	an existing file name,
       but it is not required for each pattern to match.  Only the metacharac-
       ters  `*',  `?'	and `['	imply pattern matching,	the characters `~' and
       `{' being more akin to abbreviations.

       In matching filenames, the character `.'	at the beginning of a filename
       or  immediately	following  a `/', as well as the character `/' must be
       matched explicitly.  The	character `*' matches any  string  of  charac-
       ters,  including	the null string.  The character	`?' matches any	single
       character.  The sequence	`[...]'	matches	 any  one  of  the  characters
       enclosed.   Within  `[...]',  a	pair  of  characters  separated	by `-'
       matches any character lexically between the two.

       The character `~' at the	beginning of a filename	is used	 to  refer  to
       home  directories.  Standing alone, i.e.	`~' it expands to the invokers
       home directory as reflected in the value	of the	variable  _h_o_m_e_.	  When
       followed	by a name consisting of	letters, digits	and `-'	characters the
       shell searches for a user with that name	 and  substitutes  their  home
       directory;  thus	`~ken' might expand to `/usr/ken' and `~ken/chmach' to
       `/usr/ken/chmach'.  If the character `~'	is  followed  by  a  character
       other  than  a letter or	`/' or appears not at the beginning of a word,
       it is left undisturbed.

       The metanotation	`a{b,c,d}e' is a shorthand for `abe ace	ade'.  Left to
       right  order  is	 preserved, with results of matches being sorted sepa-
       rately at a low level to	preserve this order.  This  construct  may  be
       nested.	      Thus	`~source/s1/{oldls,ls}.c'      expands	    to
       `/usr/source/s1/oldls.c /usr/source/s1/ls.c' whether or not these files
       exist without any chance	of error if the	home directory for `source' is
       `/usr/source'.  Similarly `../{memo,*box}'  might  expand  to  `../memo
       ../box  ../mbox'.  (Note	that `memo' was	not sorted with	the results of
       matching	`*box'.)  As a special case  `{',  `}'	and  `{}'  are	passed
       undisturbed.

       IInnppuutt//oouuttppuutt

       The  standard  input and	standard output	of a command may be redirected
       with the	following syntax:

       < name
	    Open file _n_a_m_e (which is  first  variable,	command	 and  filename
	    expanded) as the standard input.

       << word
	    Read  the  shell  input  up	 to a line which is identical to _w_o_r_d_.
	    _W_o_r_d is not	subjected to variable, filename	or  command  substitu-
	    tion, and each input line is compared to _w_o_r_d before any substitu-
	    tions are done on this input line.	Unless a quoting `\', `"', `''
	    or	``'  appears in	_w_o_r_d variable and command substitution is per-
	    formed on the intervening lines, allowing `\' to  quote  `$',  `\'
	    and	 ``'.	Commands  which	are substituted	have all blanks, tabs,
	    and	newlines preserved, except for	the  final  newline  which  is
	    dropped.   The  resultant text is placed in	an anonymous temporary
	    file which is given	to the command as standard input.

       > name
       >! name
       >& name
       >&! name
	    The	file _n_a_m_e is used as standard output.  If the  file  does  not
	    exist  then	 it  is	created; if the	file exists, its is truncated,
	    its	previous contents being	lost.

	    If the variable _n_o_c_l_o_b_b_e_r is set, then the file must not exist  or
	    be a character special file	(e.g. a	terminal or `/dev/null') or an
	    error results.   This  helps  prevent  accidental  destruction  of
	    files.   In	 this case the `!' forms can be	used and suppress this
	    check.

	    The	forms involving	`&' route the diagnostic output	into the spec-
	    ified  file	 as  well as the standard output.  _N_a_m_e	is expanded in
	    the	same way as `<'	input filenames	are.

       >> name
       >>& name
       >>! name
       >>&! name
	    Uses file _n_a_m_e as standard output like `>' but  places  output  at
	    the	end of the file.  If the variable _n_o_c_l_o_b_b_e_r is set, then it is
	    an error for the file not to exist unless one of the `!' forms  is
	    given.  Otherwise similar to `>'.

       A  command  receives  the environment in	which the shell	was invoked as
       modified	by the input-output parameters and the presence	of the command
       in  a pipeline.	Thus, unlike some previous shells, commands run	from a
       file of shell commands have no access to	the text of  the  commands  by
       default;	 rather	they receive the original standard input of the	shell.
       The `<<'	mechanism should be used to present inline data.  This permits
       shell command scripts to	function as components of pipelines and	allows
       the shell to block read its input.   Note  that	the  default  standard
       input  for  a command run detached is nnoott modified to be	the empty file
       `/dev/null'; rather the standard	input remains as the original standard
       input  of the shell.  If	this is	a terminal and if the process attempts
       to read from the	terminal, then the process will	 block	and  the  user
       will be notified	(see JJoobbss above).

       Diagnostic output may be	directed through a pipe	with the standard out-
       put.  Simply use	the form `|&' rather than just `|'.

       EExxpprreessssiioonnss

       A number	of the builtin commands	(to be	described  subsequently)  take
       expressions, in which the operators are similar to those	of C, with the
       same precedence.	 These expressions appear in  the  _@_,  _e_x_i_t_,  _i_f_,  and
       _w_h_i_l_e commands.	The following operators	are available:

	    ||	 &&  |	^  &  ==  !=  =~  !~  <=  >=  <	 >  <<	>>  +  -  *  /
       %  !  ~	(  )

       Here the	precedence increases to	the right, `=='	`!='  `=~'  and	 `!~',
       `<='  `>='  `<'	and  `>',  `<<'	and `>>', `+' and `-', `*' `/' and `%'
       being, in groups, at the	same level.  The `==' `!=' `=~'	and `!~' oper-
       ators  compare  their  arguments	as strings; all	others operate on num-
       bers.  The operators `=~' and `!~' are like `!='	and `=='  except  that
       the  right  hand	 side  is  a  _p_a_t_t_e_r_n (containing, e.g.	`*'s, `?'s and
       instances of `[...]')  against which the	left hand operand is  matched.
       This  reduces the need for use of the _s_w_i_t_c_h statement in shell scripts
       when all	that is	really needed is pattern matching.

       Strings which begin with	`0' are	considered  octal  numbers.   Null  or
       missing	arguments  are	considered `0'.	 The result of all expressions
       are strings, which represent decimal numbers.  It is important to  note
       that  no	 two  components of an expression can appear in	the same word;
       except when adjacent to components of expressions which	are  syntacti-
       cally  significant  to the parser (`&' `|' `<' `>' `(' `)') they	should
       be surrounded by	spaces.

       Also available in expressions as	primitive operands are command	execu-
       tions enclosed in `{' and `}' and file enquiries	of the form `-_l	 name'
       where _l is one of:

	    r	 read access
	    w	 write access
	    x	 execute access
	    e	 existence
	    o	 ownership
	    z	 zero size
	    f	 plain file
	    d	 directory

       The specified name is command and filename expanded and then tested  to
       see if it has the specified relationship	to the real user.  If the file
       does not	exist or is inaccessible then all enquiries return false, i.e.
       `0'.  Command executions	succeed, returning true, i.e. `1', if the com-
       mand exits with status 0, otherwise they	fail,  returning  false,  i.e.
       `0'.   If more detailed status information is required then the command
       should be executed outside of an	expression  and	 the  variable	_s_t_a_t_u_s
       examined.

       CCoonnttrrooll ffllooww

       The  shell  contains a number of	commands which can be used to regulate
       the flow	of control in command files (shell scripts)  and  (in  limited
       but  useful  ways)  from	terminal input.	 These commands	all operate by
       forcing the shell to reread or skip in its input	and, due to the	imple-
       mentation, restrict the placement of some of the	commands.

       The  _f_o_r_e_a_c_h_, _s_w_i_t_c_h_, and _w_h_i_l_e statements, as well as the _i_f_-_t_h_e_n_-_e_l_s_e
       form of the _i_f statement	require	that the major keywords	 appear	 in  a
       single simple command on	an input line as shown below.

       If  the shell's input is	not seekable, the shell	buffers	up input when-
       ever a loop is being read and performs seeks in this internal buffer to
       accomplish the rereading	implied	by the loop.  (To the extent that this
       allows, backward	goto's will succeed on non-seekable inputs.)

       BBuuiillttiinn ccoommmmaannddss

       Builtin commands	are executed within the	shell.	If a  builtin  command
       occurs  as  any component of a pipeline except the last then it is exe-
       cuted in	a subshell.

       aalliiaass
       aalliiaass name
       aalliiaass name wordlist
	    The	first form prints all aliases.	The  second  form  prints  the
	    alias  for name.  The final	form assigns the specified _w_o_r_d_l_i_s_t as
	    the	alias of _n_a_m_e_; _w_o_r_d_l_i_s_t	is command and	filename  substituted.
	    _N_a_m_e is not	allowed	to be _a_l_i_a_s or _u_n_a_l_i_a_s_.

       aalllloocc
	    Shows the amount of	dynamic	memory acquired, broken	down into used
	    and	free memory.  With an argument shows the number	 of  free  and
	    used blocks	in each	size category.	The categories start at	size 8
	    and	double at each step.  This command's output  may  vary	across
	    system types, since	systems	other than the VAX may use a different
	    memory allocator.

       bbgg
       bbgg %%job ...
	    Puts the current or	specified jobs into the	background, continuing
	    them if they were stopped.

       bbrreeaakk
	    Causes  execution to resume	after the _e_n_d of the nearest enclosing
	    _f_o_r_e_a_c_h or _w_h_i_l_e_.  The remaining commands on the current line  are
	    executed.	Multi-level  breaks  are thus possible by writing them
	    all	on one line.

       bbrreeaakkssww
	    Causes a break from	a _s_w_i_t_c_h_, resuming after the _e_n_d_s_w_.

       ccaassee label:
	    A label in a _s_w_i_t_c_h	statement as discussed below.

       ccdd
       ccdd name
       cchhddiirr
       cchhddiirr name
	    Change the shell's working directory to  directory	_n_a_m_e_.	If  no
	    argument is	given then change to the home directory	of the user.
	    If	_n_a_m_e  is  not found as a subdirectory of the current directory
	    (and does not begin	with `/', `./' or `../'), then each  component
	    of	the variable _c_d_p_a_t_h is checked to see if it has	a subdirectory
	    _n_a_m_e_.  Finally, if all else	fails but _n_a_m_e	is  a  shell  variable
	    whose  value begins	with `/', then this is tried to	see if it is a
	    directory.

       ccoonnttiinnuuee
	    Continue execution of the nearest enclosing	_w_h_i_l_e or _f_o_r_e_a_c_h_.  The
	    rest of the	commands on the	current	line are executed.

       ddeeffaauulltt::
	    Labels the default case in a _s_w_i_t_c_h	statement.  The	default	should
	    come after all _c_a_s_e	labels.

       ddiirrss
	    Prints the directory stack;	the top	of the stack is	at  the	 left,
	    the	first directory	in the stack being the current directory.

       eecchhoo wordlist
       eecchhoo --nn wordlist
	    The	 specified  words  are	written	to the shells standard output,
	    separated by spaces, and terminated	with a newline unless  the  --nn
	    option is specified.

       eellssee
       eenndd
       eennddiiff
       eennddssww
	    See	 the  description of the _f_o_r_e_a_c_h_, _i_f_, _s_w_i_t_c_h_, and _w_h_i_l_e	state-
	    ments below.

       eevvaall arg	...
	    (As	in _s_h(1).)  The	arguments are read as input to the  shell  and
	    the	 resulting  command(s)	executed in the	context	of the current
	    shell.  This is usually used to execute commands generated as  the
	    result  of	command	or variable substitution, since	parsing	occurs
	    before these substitutions.	 See _t_s_e_t(1) for an example  of	 using
	    _e_v_a_l.

       eexxeecc command
	    The	specified command is executed in place of the current shell.

       eexxiitt
       eexxiitt(expr)
	    The	 shell	exits  either  with  the  value	of the _s_t_a_t_u_s variable
	    (first form) or with the  value  of	 the  specified	 _e_x_p_r  (second
	    form).

       ffgg
       ffgg %%job ...
	    Brings the current or specified jobs into the foreground, continu-
	    ing	them if	they were stopped.

       ffoorreeaacchh name (wordlist)
	   ...
       eenndd
	    The	variable _n_a_m_e is successively set to each member  of  _w_o_r_d_l_i_s_t
	    and	the sequence of	commands between this command and the matching
	    _e_n_d	are executed.  (Both _f_o_r_e_a_c_h and _e_n_d must appear alone on sep-
	    arate lines.)

	    The	builtin	command	_c_o_n_t_i_n_u_e may be	used to	continue the loop pre-
	    maturely and the builtin command  _b_r_e_a_k  to	 terminate  it	prema-
	    turely.   When this	command	is read	from the terminal, the loop is
	    read up once prompting with	`?' before any statements in the  loop
	    are	 executed.  If you make	a mistake typing in a loop at the ter-
	    minal you can rub it out.

       gglloobb wordlist
	    Like _e_c_h_o but no `\' escapes are recognized	and words  are	delim-
	    ited  by null characters in	the output.  Useful for	programs which
	    wish to use	the shell to filename expand a list of words.

       ggoottoo word
	    The	specified _w_o_r_d is filename and command	expanded  to  yield  a
	    string  of	the form `label'.  The shell rewinds its input as much
	    as possible	and searches for a line	of the form `label:'  possibly
	    preceded  by blanks	or tabs.  Execution continues after the	speci-
	    fied line.

       hhaasshhssttaatt
	    Print a statistics line indicating how effective the internal hash
	    table  has	been  at  locating commands (and avoiding _e_x_e_c's).  An
	    _e_x_e_c is attempted for each component of the	_p_a_t_h  where  the  hash
	    function  indicates	 a  possible  hit, and in each component which
	    does not begin with	a `/'.

       hhiissttoorryy
       hhiissttoorryy _n
       hhiissttoorryy --rr _n
       hhiissttoorryy --hh _n
	    Displays the history event list; if	_n is given  only  the  _n  most
	    recent  events  are	 printed.  The --rr option reverses the order of
	    printout to	be most	recent first rather than oldest	first.	The --hh
	    option  causes the history list to be printed without leading num-
	    bers.  This	is used	to produce files suitable for sourceing	 using
	    the	-h option to _s_o_u_r_c_e.

       iiff (expr) command
	    If	the  specified expression evaluates true, then the single _c_o_m_-
	    _m_a_n_d with arguments	is executed.  Variable substitution on _c_o_m_m_a_n_d
	    happens  early,  at	 the  same time	it does	for the	rest of	the _i_f
	    command.  _C_o_m_m_a_n_d must be a	simple command,	not a pipeline,	a com-
	    mand  list,	 or  a parenthesized command list.  Input/output redi-
	    rection occurs even	if _e_x_p_r	is false, when command is nnoott executed
	    (this is a bug).

       iiff (expr) tthheenn
	   ...
       eellssee iiff (expr2) tthheenn
	   ...
       eellssee
	   ...
       eennddiiff
	    If	the specified _e_x_p_r is true then	the commands to	the first _e_l_s_e
	    are	executed; otherwise if _e_x_p_r_2 is	true then the commands to  the
	    second  _e_l_s_e  are  executed, etc.  Any number of _e_l_s_e_-_i_f pairs are
	    possible; only one _e_n_d_i_f is	needed.	 The  _e_l_s_e  part  is  likewise
	    optional.	(The words _e_l_s_e	and _e_n_d_i_f must appear at the beginning
	    of input lines; the	_i_f must	appear alone  on  its  input  line  or
	    after an _e_l_s_e_._)

       jjoobbss
       jjoobbss --ll
	    Lists  the active jobs; given the --ll options lists process id's in
	    addition to	the normal information.

       kkiillll %%job
       kkiillll --sig %%job ...
       kkiillll pid
       kkiillll --sig pid ...
       kkiillll --ll
	    Sends either the TERM (terminate) signal or	the  specified	signal
	    to	the  specified jobs or processes.  Signals are either given by
	    number or by names (as given in _/_u_s_r_/_i_n_c_l_u_d_e_/_s_i_g_n_a_l_._h_, stripped of
	    the	 prefix	``SIG'').  The signal names are	listed by ``kill -l''.
	    There is no	default, saying	just `kill' does not send a signal  to
	    the	 current job.  If the signal being sent	is TERM	(terminate) or
	    HUP	(hangup), then the job or process will be sent	a  CONT	 (con-
	    tinue) signal as well.

       lliimmiitt
       lliimmiitt _r_e_s_o_u_r_c_e
       lliimmiitt _r_e_s_o_u_r_c_e _m_a_x_i_m_u_m_-_u_s_e
       lliimmiitt --hh
       lliimmiitt --hh	_r_e_s_o_u_r_c_e
       lliimmiitt --hh	_r_e_s_o_u_r_c_e _m_a_x_i_m_u_m_-_u_s_e
	    Limits  the	consumption by the current process and each process it
	    creates to not individually	exceed _m_a_x_i_m_u_m_-_u_s_e  on	the  specified
	    _r_e_s_o_u_r_c_e.	If  no _m_a_x_i_m_u_m_-_u_s_e is given, then the current limit is
	    printed; if	no _r_e_s_o_u_r_c_e is given, then all limitations are	given.
	    If	the  --hh	flag is	given, the hard	limits are used	instead	of the
	    current limits.  The hard limits impose a ceiling on the values of
	    the	 current  limits.  Only	the super-user may raise the hard lim-
	    its, but a user may	lower or raise the current limits  within  the
	    legal range.

	    Resources controllable currently include _c_p_u_t_i_m_e (the maximum num-
	    ber	of cpu-seconds to be used  by  each  process),	_f_i_l_e_s_i_z_e  (the
	    largest  single  file which	can be created), _d_a_t_a_s_i_z_e (the maximum
	    growth of the data+stack region via	_s_b_r_k(2)	beyond the end of  the
	    program  text),  _s_t_a_c_k_s_i_z_e (the maximum size of the	automatically-
	    extended stack region), and	_c_o_r_e_d_u_m_p_s_i_z_e (the size of the  largest
	    core dump that will	be created).

	    The	_m_a_x_i_m_u_m_-_u_s_e may	be given as a (floating	point or integer) num-
	    ber	followed by a scale factor.  For all limits other than _c_p_u_t_i_m_e
	    the	default	scale is `k' or	`kilobytes' (1024 bytes); a scale fac-
	    tor	of `m' or `megabytes' may  also	 be  used.   For  _c_p_u_t_i_m_e  the
	    default  scaling  is  `seconds',  while `m'	for minutes or `h' for
	    hours, or a	time of	the form `mm:ss' giving	 minutes  and  seconds
	    may	be used.

	    For	both _r_e_s_o_u_r_c_e names and	scale factors, unambiguous prefixes of
	    the	names suffice.

       llooggiinn
	    Terminate  a  login	 shell,	 replacing  it	with  an  instance  of
	    //bbiinn//llooggiinn..	  This is one way to log off, included for compatibil-
	    ity	with _s_h(1).

       llooggoouutt
	    Terminate a	login shell.  Especially useful	if _i_g_n_o_r_e_e_o_f is	set.

       nniiccee
       nniiccee +number
       nniiccee command
       nniiccee +number command
	    The	first form sets	the scheduling priority	for this shell	to  4.
	    The	 second	form sets the priority to the given number.  The final
	    two	forms run command at priority 4	and _n_u_m_b_e_r respectively.   The
	    greater the	number,	the less cpu the process will get.  The	super-
	    user may specify negative priority by using	 `nice	-number	 ...'.
	    Command  is	 always	 executed in a sub-shell, and the restrictions
	    placed on commands in simple _i_f statements apply.

       nnoohhuupp
       nnoohhuupp command
	    The	first form can be used in shell	scripts	to cause hangups to be
	    ignored  for  the remainder	of the script.	The second form	causes
	    the	specified command to be	run with hangups  ignored.   All  pro-
	    cesses detached with `&' are effectively _n_o_h_u_p_'_e_d_.

       nnoottiiffyy
       nnoottiiffyy %%job ...
	    Causes the shell to	notify the user	asynchronously when the	status
	    of the current or specified	jobs changes; normally notification is
	    presented  before  a prompt.  This is automatic if the shell vari-
	    able _n_o_t_i_f_y	is set.

       oonniinnttrr
       oonniinnttrr  -
       oonniinnttrr  label
	    Control the	action of the shell on	interrupts.   The  first  form
	    restores the default action	of the shell on	interrupts which is to
	    terminate shell scripts or to return to the	terminal command input
	    level.   The  second  form	`onintr	-' causes all interrupts to be
	    ignored.  The final	form causes  the  shell	 to  execute  a	 `goto
	    label' when	an interrupt is	received or a child process terminates
	    because it was interrupted.

	    In any case, if the	shell is running detached and  interrupts  are
	    being  ignored, all	forms of _o_n_i_n_t_r	have no	meaning	and interrupts
	    continue to	be ignored by the shell	and all	invoked	commands.

       ppooppdd
       ppooppdd +n
	    Pops the directory stack, returning	 to  the  new  top  directory.
	    With  an  argument	`+_n' discards the _nth entry in the stack.  The
	    elements of	the directory stack are	numbered from  0  starting  at
	    the	top.

       ppuusshhdd
       ppuusshhdd name
       ppuusshhdd +n
	    With  no  arguments,  _p_u_s_h_d	 exchanges the top two elements	of the
	    directory stack.  Given a _n_a_m_e argument, _p_u_s_h_d changes to the  new
	    directory  (ala  _c_d_)  and pushes the old current working directory
	    (as	in _c_s_w_)	onto the directory stack.  With	 a  numeric  argument,
	    rotates  the  _nth argument of the directory	stack around to	be the
	    top	element	and changes to it.  The	members	of the directory stack
	    are	numbered from the top starting at 0.

       rreehhaasshh
	    Causes  the	internal hash table of the contents of the directories
	    in the _p_a_t_h	variable to be recomputed.  This is needed if new com-
	    mands  are	added  to directories in the _p_a_t_h while	you are	logged
	    in.	 This should only be necessary if you add commands to  one  of
	    your  own directories, or if a systems programmer changes the con-
	    tents of one of the	system directories.

       rreeppeeaatt count command
	    The	specified _c_o_m_m_a_n_d which	is subject to the same restrictions as
	    the	 _c_o_m_m_a_n_d in the	one line _i_f statement above, is	executed _c_o_u_n_t
	    times.  I/O	redirections occur exactly once, even if _c_o_u_n_t is 0.

       sseett
       sseett name
       sseett name=word
       sseett name[index]=word
       sseett name=(wordlist)
	    The	first form of the command shows	the value of all  shell	 vari-
	    ables.   Variables	which  have  other than	a single word as value
	    print as a parenthesized word list.	 The second form sets _n_a_m_e  to
	    the	 null  string.	 The  third form sets _n_a_m_e to the single _w_o_r_d_.
	    The	fourth form sets the _i_n_d_e_x_'_t_h component	of name	to word;  this
	    component  must  already  exist.   The final form sets _n_a_m_e	to the
	    list of words in _w_o_r_d_l_i_s_t_.	In all cases the value is command  and
	    filename expanded.

	    These arguments may	be repeated to set multiple values in a	single
	    set	command.  Note however,	that variable  expansion  happens  for
	    all	arguments before any setting occurs.

       sseetteennvv
       sseetteennvv name value
       sseetteennvv name
	    The	 first form lists all current environment variables.  The last
	    form sets the value	of environment variable	_n_a_m_e to	 be  _v_a_l_u_e_,  a
	    single string.  The	second form sets _n_a_m_e to an empty string.  The
	    most commonly used environment variable USER, TERM,	and  PATH  are
	    automatically  imported  to	 and  exported	from the _c_s_h variables
	    _u_s_e_r_, _t_e_r_m_,	and _p_a_t_h_; there	is no need to use _s_e_t_e_n_v for these.

       sshhiifftt
       sshhiifftt variable
	    The	members	of _a_r_g_v	are shifted to the left,  discarding  _a_r_g_v_[_1_]_.
	    It	is  an	error  for _a_r_g_v	not to be set or to have less than one
	    word as value.  The	second form performs the same function on  the
	    specified variable.

       ssoouurrccee name
       ssoouurrccee --hh name
	    The	 shell	reads  commands	 from  _n_a_m_e_.   _S_o_u_r_c_e  commands	may be
	    nested; if they are	nested too deeply the shell  may  run  out  of
	    file  descriptors.	 An  error in a	_s_o_u_r_c_e at any level terminates
	    all	nested _s_o_u_r_c_e commands.	 Normally input	during _s_o_u_r_c_e commands
	    is	not  placed on the history list; the -h	option causes the com-
	    mands to be	placed in the history list without being executed.

       ssttoopp
       ssttoopp %%job ...
	    Stops the current or specified job which is	executing in the back-
	    ground.

       ssuussppeenndd
	    Causes  the	 shell	to  stop in its	tracks,	much as	if it had been
	    sent a stop	signal with ^^ZZ.	 This  is  most	 often	used  to  stop
	    shells started by _s_u(1).

       sswwiittcchh (string)
       ccaassee str1:
	   ...
	 bbrreeaakkssww
       ...
       ddeeffaauulltt::
	   ...
	 bbrreeaakkssww
       eennddssww
	    Each  case	label  is  successively	matched, against the specified
	    _s_t_r_i_n_g which is first command and  filename	 expanded.   The  file
	    metacharacters  `*',  `?'  and  `[...]'  may  be  used in the case
	    labels, which are variable expanded.  If none of the labels	 match
	    before a `default' label is	found, then the	execution begins after
	    the	default	label.	Each case label	and  the  default  label  must
	    appear  at	the  beginning	of a line.  The	command	_b_r_e_a_k_s_w	causes
	    execution to continue after	the _e_n_d_s_w_.  Otherwise control may fall
	    through  case  labels  and	default	 labels	 as in C.  If no label
	    matches and	there is no default,  execution	 continues  after  the
	    _e_n_d_s_w_.

       ttiimmee
       ttiimmee command
	    With  no  argument,	 a  summary of time used by this shell and its
	    children is	printed.  If arguments are given the specified	simple
	    command  is	 timed	and a time summary as described	under the _t_i_m_e
	    variable is	printed.  If necessary,	an extra shell is  created  to
	    print the time statistic when the command completes.

       uummaasskk
       uummaasskk value
	    The	 file  creation	 mask  is displayed (first form) or set	to the
	    specified value (second form).  The	mask is	given in octal.	  Com-
	    mon	values for the mask are	002 giving all access to the group and
	    read and execute access to others or 022 giving all	access	except
	    no write access for	users in the group or others.

       uunnaalliiaass pattern
	    All	aliases	whose names match the specified	pattern	are discarded.
	    Thus all aliases are removed by `unalias *'.  It is	not  an	 error
	    for	nothing	to be _u_n_a_l_i_a_s_e_d_.

       uunnhhaasshh
	    Use	 of the	internal hash table to speed location of executed pro-
	    grams is disabled.

       uunnlliimmiitt
       uunnlliimmiitt _r_e_s_o_u_r_c_e
       uunnlliimmiitt --hh
       uunnlliimmiitt --hh _r_e_s_o_u_r_c_e
	    Removes the	limitation on _r_e_s_o_u_r_c_e.	 If no _r_e_s_o_u_r_c_e	is  specified,
	    then  all  _r_e_s_o_u_r_c_e	 limitations are removed.  If --hh is given, the
	    corresponding hard limits are removed.  Only the super-user	may do
	    this.

       uunnsseett pattern
	    All	variables whose	names match the	specified pattern are removed.
	    Thus all variables are removed by `unset *'; this  has  noticeably
	    distasteful	 side-effects.	 It  is	not an error for nothing to be
	    _u_n_s_e_t_.

       uunnsseetteennvv	pattern
	    Removes all	variables whose	name match the specified pattern  from
	    the	 environment.	See  also  the _s_e_t_e_n_v command above and	_p_r_i_n_t_-
	    _e_n_v(1).

       wwaaiitt
	    All	background jobs	are waited for.	 It the	shell is  interactive,
	    then  an  interrupt	 can disrupt the wait, at which	time the shell
	    prints names and job numbers of all	jobs known to be outstanding.

       wwhhiillee (expr)
	   ...
       eenndd
	    While the specified	expression evaluates  non-zero,	 the  commands
	    between  the  _w_h_i_l_e	and the	matching end are evaluated.  _B_r_e_a_k and
	    _c_o_n_t_i_n_u_e may be used to terminate  or  continue  the  loop	prema-
	    turely.   (The  _w_h_i_l_e  and	_e_n_d  must  appear alone	on their input
	    lines.)  Prompting occurs here the first time through the loop  as
	    for	the _f_o_r_e_a_c_h statement if the input is a	terminal.

       %%job
	    Brings the specified job into the foreground.

       %%job &&
	    Continues the specified job	in the background.

       @@
       @@ name =	expr
       @@ name[index] = expr
	    The	 first form prints the values of all the shell variables.  The
	    second form	sets the specified _n_a_m_e	to the value of	_e_x_p_r_.  If  the
	    expression	contains  `<', `>', `&'	or `|' then at least this part
	    of the expression must be placed within `('	`)'.  The  third  form
	    assigns  the value of _e_x_p_r to the _i_n_d_e_x_'_t_h argument	of _n_a_m_e_.  Both
	    _n_a_m_e and its _i_n_d_e_x_'_t_h component must already exist.

	    The	operators `*=',	`+=', etc are available	as in  C.   The	 space
	    separating	the  name  from	 the  assignment operator is optional.
	    Spaces are,	however, mandatory in separating  components  of  _e_x_p_r
	    which would	otherwise be single words.

	    Special  postfix  `++'  and	`--' operators increment and decrement
	    _n_a_m_e respectively, i.e. `@	i++'.

       PPrree--ddeeffiinneedd aanndd eennvviirroonnmmeenntt vvaarriiaabblleess

       The following variables have special meaning to the shell.   Of	these,
       _a_r_g_v_,  _c_w_d_,  _h_o_m_e_, _p_a_t_h_,	_p_r_o_m_p_t_,	_s_h_e_l_l and _s_t_a_t_u_s are always set	by the
       shell.  Except for _c_w_d and _s_t_a_t_u_s this setting occurs only at  initial-
       ization;	 these variables will not then be modified unless this is done
       explicitly by the user.

       This shell copies the environment variable USER into the	variable _u_s_e_r_,
       TERM  into  _t_e_r_m_,  and  HOME  into _h_o_m_e_,	and copies these back into the
       environment whenever the	normal shell variables are reset.   The	 envi-
       ronment variable	PATH is	likewise handled; it is	not necessary to worry
       about its setting other than in the file	_._c_s_h_r_c as  inferior  _c_s_h  pro-
       cesses will import the definition of _p_a_t_h from the environment, and re-
       export it if you	then change it.

       aarrggvv	      Set to the arguments to the shell, it is from this vari-
		      able  that  positional  parameters are substituted, i.e.
		      `$1' is replaced by `$argv[1]', etc.

       ccddppaatthh	      Gives a list of alternate	directories searched  to  find
		      subdirectories in	_c_h_d_i_r commands.

       ccwwdd	      The full pathname	of the current directory.

       eecchhoo	      Set  when	 the  --xx command line option is	given.	Causes
		      each command and its arguments to	be echoed just	before
		      it is executed.  For non-builtin commands	all expansions
		      occur  before  echoing.	Builtin	 commands  are	echoed
		      before  command  and  filename substitution, since these
		      substitutions are	then done selectively.

       ffiilleecc	      Enable file name completion.

       hhiissttcchhaarrss      Can be given a string value  to  change  the  characters
		      used  in	history	 substitution.	The first character of
		      its value	is used	as the history substitution character,
		      replacing	the default character !.  The second character
		      of its value replaces the	character |^ in quick substitu-
		      tions.

       hhiissttoorryy	      Can  be given a numeric value to control the size	of the
		      history list.  Any command which has been	referenced  in
		      this  many events	will not be discarded.	Too large val-
		      ues of _h_i_s_t_o_r_y may run the shell	out  of	 memory.   The
		      last  executed  command  is  always saved	on the history
		      list.

       hhoommee	      The home directory of the	invoker, initialized from  the
		      environment.   The  filename  expansion of `~~' refers to
		      this variable.

       iiggnnoorreeeeooff      If set the shell ignores end-of-file from	input  devices
		      which are	terminals.  This prevents shells from acciden-
		      tally being killed by control-D's.

       mmaaiill	      The files	where the shell	checks for mail.  This is done
		      after  each  command  completion	which will result in a
		      prompt, if a specified interval has elapsed.  The	 shell
		      says  `You  have	new mail.'  if the file	exists with an
		      access time not greater than its modify time.

		      If the first word	of the value of	 _m_a_i_l  is  numeric  it
		      specifies	 a  different  mail checking interval, in sec-
		      onds, than the default, which is 10 minutes.

		      If multiple mail files are  specified,  then  the	 shell
		      says  `New  mail in _n_a_m_e'	when there is mail in the file
		      _n_a_m_e_.

       nnoocclloobbbbeerr      As described in the section  on  _I_n_p_u_t_/_o_u_t_p_u_t_,  restric-
		      tions  are  placed  on output redirection	to insure that
		      files are	not  accidentally  destroyed,  and  that  `>>'
		      redirections refer to existing files.

       nnoogglloobb	      If  set,	filename expansion is inhibited.  This is most
		      useful in	shell scripts which are	not dealing with file-
		      names,  or  after	 a list	of filenames has been obtained
		      and further expansions are not desirable.

       nnoonnoommaattcchh      If set, it is not	an error for a filename	 expansion  to
		      not  match any existing files; rather the	primitive pat-
		      tern is returned.	 It is still an	error for  the	primi-
		      tive pattern to be malformed, i.e.  `echo	[' still gives
		      an error.

       nnoottiiffyy	      If set, the shell	notifies asynchronously	of job comple-
		      tions.  The default is to	rather present job completions
		      just before printing a prompt.

       ppaatthh	      Each word	of the path variable specifies a directory  in
		      which  commands  are to be sought	for execution.	A null
		      word specifies the current directory.  If	 there	is  no
		      _p_a_t_h  variable  then  only full path names will execute.
		      The usual	search path is `.', `/bin' and `/usr/bin', but
		      this may vary from system	to system.  For	the super-user
		      the default search path is `/bin', `/sbin', `/usr/sbin',
		      and  `/usr/bin'.	 A shell which is given	neither	the --cc
		      nor the --tt option	will normally hash the contents	of the
		      directories  in  the _p_a_t_h	variable after reading _._c_s_h_r_c_,
		      and each time the	_p_a_t_h variable is reset.	 If  new  com-
		      mands  are added to these	directories while the shell is
		      active, it may be	necessary to give the  _r_e_h_a_s_h  or  the
		      commands may not be found.

       pprroommpptt	      The  string which	is printed before each command is read
		      from an interactive terminal input.  If a	`!' appears in
		      the string it will be replaced by	the current event num-
		      ber unless a preceding `\' is given.  Default is	`%  ',
		      or `# ' for the super-user.

       ssaavveehhiisstt	      is  given	 a  numeric  value  to	control	 the number of
		      entries of the history list that are saved in ~/.history
		      when the user logs out.  Any command which has been ref-
		      erenced in this many events will be saved.  During start
		      up  the  shell  sources ~/.history into the history list
		      enabling history to be saved across logins.   Too	 large
		      values of	_s_a_v_e_h_i_s_t will slow down	the shell during start
		      up.

       sshheellll	      The file in which	the shell resides.  This  is  used  in
		      forking  shells  to  interpret  files which have execute
		      bits set,	but which are not executable  by  the  system.
		      (See  the	 description  of _N_o_n_-_b_u_i_l_t_i_n _C_o_m_m_a_n_d _E_x_e_c_u_t_i_o_n
		      below.)  Initialized to the (system-dependent)  home  of
		      the shell.

       ssttaattuuss	      The  status  returned by the last	command.  If it	termi-
		      nated abnormally,	then 0200  is  added  to  the  status.
		      Builtin  commands	which fail return exit status `1', all
		      other builtin commands set status	`0'.

       ttiimmee	      Controls automatic timing	of commands.  If set, then any
		      command which takes more than this many cpu seconds will
		      cause a line giving user,	system,	and real times	and  a
		      utilization  percentage  which is	the ratio of user plus
		      system times to real time	to be printed when  it	termi-
		      nates.

       vveerrbboossee	      Set  by  the --vv command line option, causes the words of
		      each command to be printed after history substitution.

       NNoonn--bbuuiillttiinn ccoommmmaanndd eexxeeccuuttiioonn

       When a command to be executed is	found to not be	a builtin command  the
       shell  attempts to execute the command via _e_x_e_c_v_e(2).  Each word	in the
       variable	_p_a_t_h names a directory from which the shell  will  attempt  to
       execute	the command.  If it is given neither a --cc nor a	--tt option, the
       shell will hash the names in these directories into an  internal	 table
       so that it will only try	an _e_x_e_c	in a directory if there	is a possibil-
       ity that	the command resides there.  This greatly speeds	command	 loca-
       tion when a large number	of directories are present in the search path.
       If this mechanism has been turned off (via _u_n_h_a_s_h), or if the shell was
       given a --cc or --tt	argument, and in any case for each directory component
       of _p_a_t_h which does not begin with a `/',	the  shell  concatenates  with
       the  given  command  name  to  form a path name of a file which it then
       attempts	to execute.

       Parenthesized commands are always executed in a subshell.  Thus `(cd  ;
       pwd)  ;	pwd'  prints  the  _h_o_m_e	 directory; leaving you	where you were
       (printing this after the	home directory), while `cd ; pwd'  leaves  you
       in  the	_h_o_m_e directory.	 Parenthesized commands	are most often used to
       prevent _c_h_d_i_r from affecting the	current	shell.

       If the file has execute permissions but is not an executable binary  to
       the  system,  then it is	assumed	to be a	file containing	shell commands
       and a new shell is spawned to read it.

       If there	is an _a_l_i_a_s for	_s_h_e_l_l then the words  of  the  alias  will  be
       prepended  to  the  argument list to form the shell command.  The first
       word of the _a_l_i_a_s should	be the full  path  name	 of  the  shell	 (e.g.
       `$shell').   Note that this is a	special, late occurring, case of _a_l_i_a_s
       substitution, and only allows words to be  prepended  to	 the  argument
       list without modification.

       AArrgguummeenntt	lliisstt pprroocceessssiinngg

       If argument 0 to	the shell is `-' then this is a	login shell.  The flag
       arguments are interpreted as follows:

       --bb   This flag forces a ``break'' from option processing,  causing  any
	    further  shell  arguments  to  be treated as non-option arguments.
	    The	remaining arguments will not be	interpreted as shell  options.
	    This  may be used to pass options to a shell script	without	confu-
	    sion or possible subterfuge.  The shell will not run a set-user ID
	    script without this	option.

       --cc   Commands  are read from the	(single) following argument which must
	    be present.	 Any remaining arguments are placed in _a_r_g_v_.

       --ee   The	shell exits if any invoked command  terminates	abnormally  or
	    yields a non-zero exit status.

       --ff   The	 shell	will  start faster, because it will neither search for
	    nor	execute	commands from the file `.cshrc'	in the invoker's  home
	    directory.

       --ii   The	shell is interactive and prompts for its top-level input, even
	    if it appears to not be a terminal.	 Shells	are interactive	 with-
	    out	this option if their inputs and	outputs	are terminals.

       --nn   Commands  are  parsed,  but	 not executed.	This aids in syntactic
	    checking of	shell scripts.

       --ss   Command input is taken from	the standard input.

       --tt   A single line of input is read and executed.  A `\'	may be used to
	    escape  the	 newline  at  the  end	of this	line and continue onto
	    another line.

       --vv   Causes the _v_e_r_b_o_s_e variable	to be set, with	the effect  that  com-
	    mand input is echoed after history substitution.

       --xx   Causes  the	 _e_c_h_o  variable	to be set, so that commands are	echoed
	    immediately	before execution.

       --VV   Causes the _v_e_r_b_o_s_e variable	to be set even before `.cshrc' is exe-
	    cuted.

       --XX   Is to --xx as	--VV is to --vv..

       After processing	of flag	arguments, if arguments	remain but none	of the
       --cc,, --ii,, --ss,, or --tt options was given, the	first argument is taken	as the
       name  of	a file of commands to be executed.  The	shell opens this file,
       and saves its name for possible resubstitution  by  `$0'.   Since  many
       systems	use  either  the  standard version 6 or	version	7 shells whose
       shell scripts are not compatible	with this shell, the shell  will  exe-
       cute  such a `standard' shell if	the first character of a script	is not
       a `#', i.e. if the script does not start	 with  a  comment.   Remaining
       arguments initialize the	variable _a_r_g_v_.

       SSiiggnnaall hhaannddlliinngg

       The shell normally ignores _q_u_i_t signals.	 Jobs running detached (either
       by `&' or the _b_g	or %%......	&& commands) are	immune	to  signals  generated
       from  the  keyboard,  including hangups.	 Other signals have the	values
       which the shell inherited from its  parent.   The  shells  handling  of
       interrupts  and terminate signals in shell scripts can be controlled by
       _o_n_i_n_t_r_.	Login shells catch the _t_e_r_m_i_n_a_t_e signal; otherwise this	signal
       is  passed  on to children from the state in the	shell's	parent.	 In no
       case are	interrupts allowed when	a login	 shell	is  reading  the  file
       `.logout'.

AAUUTTHHOORR
       William	Joy.   Job  control  and directory stack features first	imple-
       mented by J.E. Kulp of I.I.A.S.A, Laxenburg,  Austria,  with  different
       syntax  than  that  used	now.  File name	completion code	written	by Ken
       Greer, HP Labs.

FFIILLEESS
       ~/.cshrc		Read at	beginning of execution by each shell.
       ~/.login		Read by	login shell, after `.cshrc' at login.
       ~/.logout	Read by	login shell, at	logout.
       /bin/sh		Standard shell,	for shell scripts not starting with a `#'.
       /tmp/sh*		Temporary file for `<<'.
       /etc/passwd	Source of home directories for `~name'.

LLIIMMIITTAATTIIOONNSS
       Words can be no longer than 1024	characters.  The system	 limits	 argu-
       ment  lists  to 10240 characters.  The number of	arguments to a command
       which involves filename expansion is limited to 1/6'th  the  number  of
       characters allowed in an	argument list.	Command	substitutions may sub-
       stitute no more characters than are allowed in an  argument  list.   To
       detect  looping,	 the shell restricts the number	of _a_l_i_a_s substitutions
       on a single line	to 20.

SSEEEE AALLSSOO
       sh(1), access(2), execve(2), fork(2),  killpg(2),  pipe(2),  sigvec(2),
       umask(2),  setrlimit(2),	 wait(2),  tty(4),  a.out(5),  environ(7), `An
       introduction to the C shell'

BBUUGGSS
       When a command is restarted from	a stop,	the shell prints the directory
       it started in if	this is	different from the current directory; this can
       be misleading (i.e. wrong) as the  job  may  have  changed  directories
       internally.

       Shell   builtin	 functions  are	 not  stoppable/restartable.   Command
       sequences of the	form `a	; b ; c' are also not handled gracefully  when
       stopping	is attempted.  If you suspend `b', the shell will then immedi-
       ately execute `c'.  This	is especially  noticeable  if  this  expansion
       results	from  an _a_l_i_a_s_.	 It suffices to	place the sequence of commands
       in ()'s to force	it to a	subshell, i.e. `( a ; b	; c )'.

       Control over tty	output after processes are started is primitive;  per-
       haps  this  will	 inspire  someone  to  work on a good virtual terminal
       interface.  In a	 virtual  terminal  interface  much  more  interesting
       things could be done with output	control.

       Alias substitution is most often	used to	clumsily simulate shell	proce-
       dures; shell procedures should be provided rather than aliases.

       Commands	within loops, prompted for by `?', are not placed in the  _h_i_s_-
       _t_o_r_y list.  Control structure should be parsed rather than being	recog-
       nized as	built-in commands.  This would allow control  commands	to  be
       placed  anywhere,  to be	combined with `|', and to be used with `&' and
       `;' metasyntax.

       It should be possible to	use the	`:' modifiers on the output of command
       substitutions.  All and more than one `:' modifier should be allowed on
       `$' substitutions.

       The way the ffiilleecc facility is implemented is ugly and expensive.



4th Berkeley Distribution      November	27, 1996			CSH(1)
